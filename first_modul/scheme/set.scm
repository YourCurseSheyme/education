;; O(N)
(define (element-of-set? x set)
  (cond ((null? set) #f)
        ((= x (car set)) #t)
        ((< x (car set)) #f)
        (else (element-of-set? x (cdr set)))))

;; O(N)
(define (adjoin x set)
  (cond ((null? set) (cons x '()))
        ((null? (cdr set)) (if (> x (car set)) (set-cdr! set (cons x '()))
                               (cons x set)))
        (else (cond ((< x (cadr set)) (set-cdr! set (cons x (cdr set))))
                    (else (adjoin x (cdr set)))))))

;; O(N)
(define (checker set)
  (cond ((null? set) '())
        ((null? (cdr set)) set)
        ((symbol? (car set)) (if (string>? (symbol->string (car set)) (symbol->string (cadr set)))
                                 set
                                 (reverse set)))
        ((< (car set) (cadr set)) set)
        (else (reverse set))))

;; там по-хорошему надо функции обновить и для множеств символов, но мне лень

;; task 1 (O(N^2))
(define (list->set xs)
  (let ((set (adjoin (car xs) '())))
    (define (iter xs set)
      (cond ((null? xs) set)
            ((element-of-set? (car xs) set) (iter (cdr xs) set))
            (else (adjoin (car xs) set)
                  (iter (cdr xs) set))))
    (iter (cdr xs) set)))

;; task 2 (O(N))
(define (set? xs)
  (define (iter xs x)
    (cond ((null? xs) #t)
          ((null? (cdr xs)) #t)
          (else (cond ((equal? (cadr xs) x) #f)
                      ((< x (cadr xs)) (iter (cdr xs) (cadr xs)))
                      (else (iter (cdr xs) x))))))
  (define (iterc xs x)
    (cond ((null? xs) #t)
          ((null? (cdr xs)) #t)
          (else (let ((cur (symbol->string x)))
                  (cond ((equal? (cadr xs) x) #f)
                        ((string>? (symbol->string (cadr xs)) cur) (iterc (cdr xs) (cadr xs)))
                        (else (iterc (cdr xs) x)))))))
  (let ((check xs))
    (cond ((null? xs) #t)
          ((symbol? (car xs)) (iterc xs (car xs)))
          (else (iter xs (car xs))))))

;; task 3 (O(N))
(define (union xs ys)
  (cond ((null? xs) ys)
        ((null? ys) xs)
        (else (let ((x (car xs))
                    (y (car ys)))
                (if (symbol? x)
                    (cond ((equal? x y) (cons x (union (cdr xs) (cdr ys))))
                          ((string<? (symbol->string x) (symbol->string y)) (cons x (union (cdr xs) ys)))
                          (else (cons y (union xs (cdr ys)))))
                    (cond ((= x y) (cons x (union (cdr xs) (cdr ys))))
                      ((< x y) (cons x (union (cdr xs) ys)))
                      (else (cons y (union xs (cdr ys))))))))))

;; task 4 (O(N))
(define (intersection xs ys)
  (if (or (null? xs) (null? ys)) '()
      (let ((x (car xs))
            (y (car ys)))
        (cond ((= x y) (cons x (intersection (cdr xs) (cdr ys))))
              ((< x y) (intersection (cdr xs) ys))
              (else (intersection xs (cdr ys)))))))

;;task 5 (O(N))
(define (difference xs ys)
  (cond ((null? xs) '())
        ((null? ys) xs)
        (else (let ((x (car xs))
                    (y (car ys)))
                (cond ((= x y) (difference (cdr xs) (cdr ys)))
                      ((< x y) (cons (car xs) (difference (cdr xs) ys)))
                      (else (difference xs (cdr ys))))))))

;; task 6 (O(N))
(define (symmetric-difference xs ys)
  (cond ((null? xs) ys)
        ((null? ys) xs)
        (else (let ((x (car xs))
                    (y (car ys)))
                (cond ((= x y) (symmetric-difference (cdr xs) (cdr ys)))
                      ((< x y) (cons (car xs) (symmetric-difference (cdr xs) ys)))
                      (else (cons (car ys) (symmetric-difference xs (cdr ys)))))))))

;; task 7 (O(N^2))
(define (set-eq? list1 list2)
  (let ((xs (checker list1))
        (ys (checker list2)))
    (cond ((and (null? xs) (null? ys)) #t)
          ((or (null? xs) (null? ys)) #f)
          (else (let ((x (car xs))
                      (y (car ys)))
                  (if (equal? x y) (set-eq? (cdr xs) (cdr ys)) #f))))))