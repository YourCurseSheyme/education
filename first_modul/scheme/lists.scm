;; task 1 (O(N))
(define (my-range a b d)
  (if (< (- b (+ a 1)) d) (list a)
      (cons a (my-range (+ a d) b d))))

;; task 2 (O(N))
(define (my-flatten xs)
  (let ((node xs) (ans '()))
    (define (loop node ans)
      (cond ((null? node) ans)
            ((pair? node) (loop (car node) (loop (cdr node) ans)))
            (else (cons node ans))))
    (loop xs '())))

;; task 3 (O(N))
(define (my-element? x xs)
  (cond ((null? xs) #f)
        ((equal? (car xs) x) #t)
        (else (my-element? x (cdr xs)))))

;; task 4 (O(N))
(define (my-filter pred? xs)
  (cond ((null? xs) '())
        ((pred? (car xs)) (cons (car xs) (my-filter pred? (cdr xs))))
        (else (my-filter pred? (cdr xs)))))

;; task 5 (O(N))
(define (my-fold-left op xs)
  (define (iter ans xs)
    (cond ((null? xs) ans)
          (else (iter (op ans (car xs)) (cdr xs)))))
  (cond ((null? xs) 0)
        (else (iter (car xs) (cdr xs)))))

;; task 6 (O(N))
(define (my-fold-right op xs)
  (define (iter ans xs)
    (if (null? (cdr xs)) ans
        (iter (op (cadr xs) ans) (cdr xs))))
  (let ((list (reverse xs)))
    (cond ((null? list) 0)
          ((null? (cdr list)) (car list))
          (else (let ((premake (op (cadr list) (car list))))
                  (iter premake (cdr list)))))))

;; task 7 (O(N))
(define (reverse! xs)
  (define (swap prev node)
    (if (null? node) prev
        (let ((premake (cdr node))
              (change (set-cdr! node prev)))
          (swap node premake))))
  (swap '() xs))

;; task 8 (O(N))
(define (cather list num roof)
  (cond ((= num roof) '())
        ((null? (car list)) (cather (cdr list) (+ 1 num) roof))
        (else (car list))))

(define (append! . other)
  (define (iter ans other num roof)
    (cond ((= num roof) ans)
          ((null? ans) (iter (car other) (cdr other) (+ 1 num) roof))
          ((null? (car other)) (iter ans (cdr other) (+ 1 num) roof))
          ((null? (cdr ans)) (set-cdr! ans (car other))
                             (iter ans (cdr other) (+ 1 num) roof))
          (else (iter (cdr ans) other num roof))))
  (let* ((roof (- (length other) 1)))
    (cond ((= roof (- 1)) '())
          (else (iter (car other) (cdr other) 0 roof)
                (cather other 0 roof)))))
    
;(define (append! xs . other)
;  (let ((list (my-flatten other)))
;    (define (iter xs other)
;      (cond ((null? xs) other)
;            ((null? (cdr xs)) (set-cdr! xs other))
;            (else (iter (cdr xs) other))))
;    (let ((premake (iter xs list)))
;      xs)))

;; task achievement

(define (cather list num roof)
  (cond ((= num roof) '())
        ((null? (car list)) (cather (cdr list) (+ 1 num) roof))
        (else (car list))))

(define (append! . other)
  (define (iter ans other num roof)
    (cond ((= num roof) ans)
          ((null? ans) (iter (car other) (cdr other) (+ 1 num) roof))
          ((null? (car other)) (iter ans (cdr other) (+ 1 num) roof))
          ((null? (cdr ans)) (set-cdr! ans (car other))
                             (iter ans (cdr other) (+ 1 num) roof))
          (else (iter (cdr ans) other num roof))))
  (let* ((roof (- (length other) 1)))
    (cond ((= roof (- 1)) '())
          (else (iter (car other) (cdr other) 0 roof)
                (cather other 0 roof)))))

(define (finder list check num)
  (if (eq? (cdr list) check) num
      (finder (cdr list) check (+ 1 num))))

(define (cycle xs len)
  (define (iter list size cur)
    (if (= size cur)
        (if (or (eq? (car list) #\space)
                (eq? (car list) #\newline)
                (eq? (car list) #\tab)
                (eq? (car list) #\return))
            (iter xs (- size 1) 1)
            size)
        (iter (cdr list) size (+ cur 1))))
  (iter xs len 1))

(define (constr list len cur)
  (if (= cur len) (cons (car list) '())
      (cons (car list) (constr (cdr list) len (+ cur 1)))))

;; O(N). правда решил умом? ;Р

(define (list-trim-right xs)
  (let* ((list (append! xs xs))
         (len (finder list xs 1))
         (size (cycle xs len)))
    (constr xs size 1)))